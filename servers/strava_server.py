import requests
import os
import time
import webbrowser
import logging


from mcp.server.fastmcp import FastMCP

from api.api_connection import (
    save_tokens,
    API_URL,
    refresh_access_token,
    CLIENT_ID,
    CLIENT_SECRET,
    load_tokens,
    AUTH_URL,
    TOKEN_URL,
)
from utils import (
    _add_athlete_id,
    _add_strava_activity_id,
    _clean_segment_efforts,
    _convert_moving_time_to_str,
    _convert_speed_to_kmh,
    _convert_distance_to_km,
    _convert_str_date_to_timestamp,
    _enrich_with_avg_slope,
    _return_only_top_n_segment_efforts,
)

# Create an MCP server
mcp = FastMCP("Strava_assistant")

# Add a prompt !


@mcp.tool()
def get_access_token_or_create_auth_url() -> str:
    """
    Gets a valid Strava API access token for non-interactive use.

    This function manages the token lifecycle automatically. It first attempts
    to load authentication tokens from a local 'strava_tokens.json' file.

    If the access token is expired, it uses the refresh token to request a new
    set of tokens from the Strava API and saves them back to the file.

    If the 'strava_tokens.json' file does not exist, the function will fail and
    print instructions to run the one-time setup script. It does not perform
    the initial interactive OAuth flow and will need the fetch_access_token tool
    afterwards to finalize the authentication.

    Returns:
        tokens (str | None) : If not None, this is the refreshed token that can be used. There is thus
        no need to call the fetch_access_token tool. Else, a web browser is opened to authenticate and
        fetch_access_token is required just after.
    """
    tokens = load_tokens()
    if tokens:
        # Check if the token is expired or will expire in the next minute
        if time.time() > tokens["expires_at"] - 60:
            tokens = refresh_access_token(tokens)
        else:
            logging.info("Access token is valid.")
        return tokens["access_token"]

    # --- Initial Authentication Flow ---
    else:
        logging.info("No tokens found. Starting initial authentication.")
        # Step 1: Get authorization from the user
        auth_params = {
            "client_id": CLIENT_ID,
            "response_type": "code",
            "redirect_uri": "http://localhost/exchange_token",
            "approval_prompt": "force",
            "scope": "read,activity:read_all",  # Request read access to all activities
        }

        auth_full_url = (
            requests.Request("GET", AUTH_URL, params=auth_params).prepare().url
        )
        logging.info(
            "\n1. A browser window will open for you to authorize this script."
        )
        logging.info(
            "2. After authorizing, Strava will redirect you to a URL that looks like 'http://localhost/exchange_token?state=&code=...&scope=...'"
        )

        webbrowser.open(auth_full_url)

        return auth_full_url


@mcp.tool()
def fetch_access_token(authentication_code: str):
    """Uses the authentication code entered by the client to finalize the
    access to the Strava API.

    Args:
        authentication_code (str) : Code that was entered by the client from the Web UI generated by
        create_auth_url tool.
    Returns:
        access_token : Access_token that will be necessary for every other tool needing to request Strava.
    """
    token_payload = {
        "client_id": CLIENT_ID,
        "client_secret": CLIENT_SECRET,
        "code": authentication_code,
        "grant_type": "authorization_code",
    }

    logging.info("Exchanging authorization code for access token...")
    response = requests.post(TOKEN_URL, data=token_payload)
    response.raise_for_status()

    new_tokens = response.json()
    try:
        token_file = os.getenv("TOKEN_FILE")
        save_tokens(new_tokens, token_file=token_file)
    except Exception:
        save_tokens(new_tokens)

    return new_tokens["access_token"]


@mcp.tool()
def get_athlete_activities(
    access_token,
    n_activities=20,
    before_date: str | None = None,
    after_date: str | None = None,
) -> list[dict]:
    """Fetches the last n activities on Strava for the authenticated athlete.
    Information only concerns the details of the activities, nothing related to the content
    of comments.

    Args:
        access_token : Token to connect to Strava API. This is returned by fetch access token tool.
        n_activities (int) : Number of activities to return for the athlete. By default, it's 20.
        before_date (str|None) : Optional date in ISO format (YYYY-MM-DD). This will fetch
        activities before this date. If it's not is ISO format,
        please propose a date in the format YYYY-MM-DD given the user's demand.
        after_date (str|None) : Optional date in ISO format (YYYY-MM-DD). This will fetch
        activities after this date. If it's not is ISO format,
        please propose a date in the format YYYY-MM-DD given the user's demand.

    Returns: A list of JSON-format for each activity. For each JSON, here are the keys returned
    with the following information:
        activity_id (int) : ID of the activity
        athlete_id (int) : ID of the athlete who performed the activity
        name (str) : Name of the activity
        sport_type (str) : Type of the activity (Ride, Run)
        distance (float) : distance in km
        total_elevation_gain (float) : elevation gain for the activity
        moving_time (str) : Time spent for the activity
        start_date (str) : date for the start of the activity
        kudos_count (int) : Number of kudos (likes) received on the activity
        comment_count (int) : Number of comments received
        athlete_count (int) : Number of athletes on the activity
        photo_count (bool) : Were there a photo downloaded on the activity
        average_speed (km/h) : Average speed
        max_speed (km/h) : max speed
        average_cadence (float) : average number of steps per minutes
        average_heart_rate (float) : heart rate during the activity
        suffer_score (int) : index on the effort. The higher, the harder the effort.
    """

    if not access_token:
        logging.info("Cannot fetch activities without a valid access token.")
        return None

    headers = {"Authorization": f"Bearer {access_token}"}
    params = {
        "before": _convert_str_date_to_timestamp(before_date) if before_date else None,
        "after": _convert_str_date_to_timestamp(after_date) if after_date else None,
        "per_page": int(n_activities),
        "page": 1,
    }

    logging.info("\nFetching recent activities from Strava...")
    response = requests.get(
        f"{API_URL}/athlete/activities", headers=headers, params=params
    )
    useful_details = [
        "id",
        "athlete",
        "name",
        "distance",
        "moving_time",
        "total_elevation_gain",
        "sport_type",
        "start_date",
        "kudos_count",
        "comment_count",
        "athlete_count",
        "photo_count",
        "average_speed",
        "max_speed",
        "average_cadence",
        "average_heartrate",
        "suffer_score",
    ]

    try:
        response.raise_for_status()
        activities = response.json()

        if not activities:
            logging.info("No activities found.")
            return None
        else:
            clean_activities = [
                {k: act.get(k) for k in useful_details} for act in activities
            ]
            _add_athlete_id(clean_activities)
            _add_strava_activity_id(clean_activities)
            _convert_moving_time_to_str(clean_activities)
            _convert_speed_to_kmh(clean_activities)
            _convert_distance_to_km(clean_activities)
        return clean_activities

    except requests.exceptions.HTTPError as err:
        logging.info(f"HTTP Error: {err}")
        logging.info(f"Response Body: {response.text}")
        return None


@mcp.tool()
def get_segment_efforts_for_activity(
    access_token: str, activity_id: int, n_segments: int = 10
) -> list[dict]:
    """
    Fetches segment efforts for a given activity. Needs activity_id as int.
    If activity_id is not fetched yet, please use the get_athlete_activities tool first where
    activity_id is in the JSON keys.

    Args:
        access_token (str): Access token for Strava API.
        activity_id (int): ID of the activity to fetch segment efforts for.
        n_segments (int): Number of segment efforts to return.

    Returns:
        list[dict]: List of segment efforts with details.
        Keys in the dict json are:
            id (int): ID of the segment effort
            name (str): Name of the segment effort
            average_watts (float): Average power output in watts
            kom_rank (int): King of the Mountain rank for the segment effort
            pr_rank (int): Personal Record rank for the segment effort
            elapsed_time (int): Elapsed time for the segment effort in seconds
            segment_id (int): ID of the segment
            segment_distance (float): Distance of the segment in meters
            segment_elevation_high (float): High elevation of the segment in meters
            segment_elevation_low (float): Low elevation of the segment in meters
    """
    if not access_token:
        logging.info("Cannot fetch segment efforts without a valid access token.")
        return None

    headers = {"Authorization": f"Bearer {access_token}"}
    params = {
        "include_all_efforts": True,
    }
    response = requests.get(
        f"{API_URL}/activities/{activity_id}", headers=headers, params=params
    )

    try:
        response.raise_for_status()
        activity = response.json()
        segment_efforts = activity.get("segment_efforts", [])
        if not segment_efforts:
            logging.info("No segment efforts found for this activity.")
            return []

        used_details = [
            "id",
            "name",
            "segment",
            "average_watts",
            "kom_rank",
            "pr_rank",
            "elapsed_time",
        ]

        cleaned_segment_efforts = [
            {k: seg.get(k) for k in used_details} for seg in segment_efforts
        ]
        _clean_segment_efforts(cleaned_segment_efforts)
        _enrich_with_avg_slope(cleaned_segment_efforts)
        truncated_segment_efforts = _return_only_top_n_segment_efforts(
            cleaned_segment_efforts, n_segments=n_segments
        )
        return truncated_segment_efforts

    except requests.exceptions.HTTPError as err:
        logging.info(f"HTTP Error: {err}")
        logging.info(f"Response Body: {response.text}")
        return None


@mcp.tool()
def get_segment_general_information(access_token: str, segment_id: int) -> dict:
    """
    Fetches general information about a specific segment by its ID.
    `get_segment_efforts_for_activity` is called to list segments in an activity.
    This tool is used to get further information about a given segment.
    If it is asked where a segment is located, this tool can be used to get the
    start and end latitude and longitude of the segment to generate a Google Maps direction from
    start_latlng to end_latlng.

    Args:
        access_token (str): Access token for Strava API.
        segment_id (int): ID of the segment to fetch information for.

    Returns:
        dict: Segment information including
        - name (str): Name of the segment
        - distance (float): Distance of the segment in kilometers
        - total_elevation_gain (float): Total elevation gain of the segment
        - elevation_profile (str): URL link to the elevation profile of the segment. Open it in a browser.
        - city (str): City where the segment is located
        - country (str): Country where the segment is located
        - start_latlng (list): Latitude and longitude of the segment start point. Create a google map link for the
        direction from start_latlng to end_latlng.
        - end_latlng (list): Latitude and longitude of the segment end point. Create a google map link for the
        direction from start_latlng to end_latlng.
        - athlete_pr_time (int): Personal Record time for the segment by the athlete
        - athlete_pr_date (str): Date of the Personal Record for the athlete
        - athlete_pr_activity_id (int): Activity ID of the Personal Record for the athlete
        - athlete_effort_count (int): Number of efforts by the athlete on this segment
        - kom_elapsed_time (int): All time record elapsed time for the segment
    """
    if not access_token:
        logging.info("Cannot fetch segment efforts without a valid access token.")
        return None

    headers = {"Authorization": f"Bearer {access_token}"}
    response = requests.get(f"{API_URL}/segments/{segment_id}", headers=headers)

    try:
        response.raise_for_status()
        segment_info = response.json()
        cleaned_segment_info = {
            "name": segment_info.get("name"),
            "distance": segment_info.get("distance", 0) / 1000,  # Convert to km
            "total_elevation_gain": segment_info.get("total_elevation_gain", 0),
            "elevation_profile": segment_info.get("elevation_profile", ""),
            "city": segment_info.get("city", ""),
            "country": segment_info.get("country", ""),
            "start_latlng": segment_info.get("start_latlng", []),
            "end_latlng": segment_info.get("end_latlng", []),
            "athlete_pr_time": segment_info["athlete_segment_stats"].get(
                "pr_elapsed_time", 0
            ),
            "athlete_pr_date": segment_info["athlete_segment_stats"].get("pr_date", ""),
            "athlete_pr_activity_id": segment_info["athlete_segment_stats"].get(
                "pr_activity_id", 0
            ),
            "athlete_effort_count": segment_info["athlete_segment_stats"].get(
                "effort_count", 0
            ),
            "kom_elapsed_time": segment_info["xoms"].get("overall", 0),
        }
        return cleaned_segment_info

    except requests.exceptions.HTTPError as err:
        logging.info(f"HTTP Error: {err}")
        logging.info(f"Response Body: {response.text}")
        return None
