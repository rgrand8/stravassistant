import requests
import os
import time
import webbrowser
import logging


# server.py
from mcp.server.fastmcp import FastMCP
from api.api_connection import (
    save_tokens,
    API_URL,
    refresh_access_token,
    CLIENT_ID,
    CLIENT_SECRET,
    load_tokens,
    AUTH_URL,
    TOKEN_URL,
)
from utils import (
    _convert_moving_time_to_str,
    _convert_speed_to_kmh,
    _convert_distance_to_km,
    _convert_str_date_to_timestamp,
)

# Create an MCP server
mcp = FastMCP("Strava_assistant")

# Add a prompt !


@mcp.tool()
def get_access_token_or_create_auth_url() -> str:
    """
    Gets a valid Strava API access token for non-interactive use.

    This function manages the token lifecycle automatically. It first attempts
    to load authentication tokens from a local 'strava_tokens.json' file.

    If the access token is expired, it uses the refresh token to request a new
    set of tokens from the Strava API and saves them back to the file.

    If the 'strava_tokens.json' file does not exist, the function will fail and
    print instructions to run the one-time setup script. It does not perform
    the initial interactive OAuth flow and will need the fetch_access_token tool
    afterwards to finalize the authentication.

    Returns:
        tokens (str | None) : If not None, this is the refreshed token that can be used. There is thus
        no need to call the fetch_access_token tool. Else, a web browser is opened to authenticate and
        fetch_access_token is required just after.
    """
    tokens = load_tokens()
    if tokens:
        # Check if the token is expired or will expire in the next minute
        if time.time() > tokens["expires_at"] - 60:
            tokens = refresh_access_token(tokens)
        else:
            logging.info("Access token is valid.")
        return tokens["access_token"]

    # --- Initial Authentication Flow ---
    else:
        logging.info("No tokens found. Starting initial authentication.")
        # Step 1: Get authorization from the user
        auth_params = {
            "client_id": CLIENT_ID,
            "response_type": "code",
            "redirect_uri": "http://localhost/exchange_token",
            "approval_prompt": "force",
            "scope": "read,activity:read_all",  # Request read access to all activities
        }

        auth_full_url = (
            requests.Request("GET", AUTH_URL, params=auth_params).prepare().url
        )
        logging.info(
            "\n1. A browser window will open for you to authorize this script."
        )
        logging.info(
            "2. After authorizing, Strava will redirect you to a URL that looks like 'http://localhost/exchange_token?state=&code=...&scope=...'"
        )

        webbrowser.open(auth_full_url)

        return auth_full_url


@mcp.tool()
def fetch_access_token(authentication_code: str):
    """Uses the authentication code entered by the client to finalize the
    access to the Strava API.

    Args:
        authentication_code (str) : Code that was entered by the client from the Web UI generated by
        create_auth_url tool.
    Returns:
        access_token : Access_token that will be necessary for every other tool needing to request Strava.
    """
    token_payload = {
        "client_id": CLIENT_ID,
        "client_secret": CLIENT_SECRET,
        "code": authentication_code,
        "grant_type": "authorization_code",
    }

    logging.info("Exchanging authorization code for access token...")
    response = requests.post(TOKEN_URL, data=token_payload)
    response.raise_for_status()

    new_tokens = response.json()
    try:
        token_file = os.getenv("TOKEN_FILE")
        save_tokens(new_tokens, token_file=token_file)
    except Exception:
        save_tokens(new_tokens)

    return new_tokens["access_token"]


@mcp.tool()
def get_athlete_activities(
    access_token,
    n_activities=20,
    before_date: str | None = None,
    after_date: str | None = None,
) -> list[dict]:
    """Fetches the last n activities on Strava for the authenticated athlete.
    Information only concerns the details of the activities, nothing related to the content
    of comments.

    Args:
        access_token : Token to connect to Strava API. This is returned by fetch access token tool.
        n_activities (int) : Number of activities to return for the athlete. By default, it's 20.
        before_date (str|None) : Optional date in ISO format (YYYY-MM-DD). This will fetch
        activities before this date. If it's not is ISO format,
        please propose a date in the format YYYY-MM-DD given the user's demand.
        after_date (str|None) : Optional date in ISO format (YYYY-MM-DD). This will fetch
        activities after this date. If it's not is ISO format,
        please propose a date in the format YYYY-MM-DD given the user's demand.

    Returns: A list of JSON-format for each activity. For each JSON, here are the keys returned
    with the following information:
        name (str) : Name of the activity
        sport_type (str) : Type of the activity (Ride, Run)
        distance (float) : distance in km
        total_elevation_gain (float) : elevation gain for the activity
        moving_time (str) : Time spent for the activity
        start_date (str) : date for the start of the activity
        kudos_count (int) : Number of kudos (likes) received on the activity
        comment_count (int) : Number of comments received
        athlete_count (int) : Number of athletes on the activity
        photo_count (bool) : Were there a photo downloaded on the activity
        average_speed (km/h) : Average speed
        max_speed (km/h) : max speed
        average_cadence (float) : average number of steps per minutes
        average_heart_rate (float) : heart rate during the activity
        suffer_score (int) : index on the effort. The higher, the harder the effort.
    """

    if not access_token:
        logging.info("Cannot fetch activities without a valid access token.")
        return None

    headers = {"Authorization": f"Bearer {access_token}"}
    params = {
        "before": _convert_str_date_to_timestamp(before_date) if before_date else None,
        "after": _convert_str_date_to_timestamp(after_date) if after_date else None,
        "per_page": int(n_activities),
        "page": 1,
    }

    logging.info("\nFetching recent activities from Strava...")
    response = requests.get(
        f"{API_URL}/athlete/activities", headers=headers, params=params
    )
    useful_details = [
        "name",
        "distance",
        "moving_time",
        "total_elevation_gain",
        "sport_type",
        "start_date",
        "kudos_count",
        "comment_count",
        "athlete_count",
        "photo_count",
        "average_speed",
        "max_speed",
        "average_cadence",
        "average_heartrate",
        "suffer_score",
    ]

    try:
        response.raise_for_status()
        activities = response.json()

        if not activities:
            logging.info("No activities found.")
        else:
            clean_activities = [
                {k: act.get(k) for k in useful_details} for act in activities
            ]
            _convert_moving_time_to_str(clean_activities)
            _convert_speed_to_kmh(clean_activities)
            _convert_distance_to_km(clean_activities)
        return clean_activities

    except requests.exceptions.HTTPError as err:
        logging.info(f"HTTP Error: {err}")
        logging.info(f"Response Body: {response.text}")
        return None


# Tool to fetch comments ?


# Add a dynamic greeting resource
@mcp.resource("greeting://{name}")
def get_greeting(name: str) -> str:
    """Get a personalized greeting"""
    return f"Hello, {name}!"
